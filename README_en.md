# SQL Booster

[![Maven Central](https://img.shields.io/maven-central/v/io.github.luminion/sql-booster)](https://mvnrepository.com/artifact/io.github.luminion/sql-booster)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)
[![GitHub](https://img.shields.io/github/stars/luminion/sql-booster?style=social)](https://github.com/luminion/sql-booster)

[简体中文](README.md) | English

SQL Booster is an enhancement toolkit for database query design, aimed at simplifying and enhancing the development of the data access layer. It provides powerful dynamic SQL dynamic conditions and suffix query mapping functions.

- [SQL Booster](#sql-booster)
  - [Features](#features)
  - [Maven Dependency](#maven-dependency)
  - [Quick Start](#quick-start)
    - [1. Create Entity Class](#1-create-entity-class)
    - [2. Mapper Xml File References SQL Fragment](#2-mapper-xml-file-references-SQL-fragment)
    - [3. Mapper Interface Inherits Specified Class](#3-mapper-interface-inherits-specified-class)
      - [Mybatis Environment, Use `PageHelperBooster`](#mybatis-environment-use-pagehelperbooster)
      - [Mybatis-plus Environment, Use `MybatisPlusBooster`](#mybatis-plus-environment-use-mybatisplusbooster)
      - [Custom Environment, Use `BoosterEngine`, No Pagination](#custom-environment-use-boosterengine-no-pagination)
      - [Custom Environment, Use `BoosterEngine`, and Override Pagination Logic](#custom-environment-use-boosterengine-and-override-pagination-logic)
  - [Usage Example](#usage-example)
  - [Core Features](#core-features)
    - [Dynamic Suffix Mapping SQL](#dynamic-suffix-mapping-sql)
      - [Dynamic Suffix Mapping Table](#dynamic-suffix-mapping-table)
      - [Parameter Example](#parameter-example)
      - [Custom Suffix Mapping](#custom-suffix-mapping)
    - [Dynamic Condition Combination SQL](#dynamic-condition-combination-sql)
      - [Parameter Format](#parameter-format)
      - [Query Type Mapping Table](#query-type-mapping-table)
      - [Basic Usage](#basic-usage)
      - [Specify Sort Fields](#specify-sort-fields)
      - [Full Function / Complex Query](#full-function--complex-query)
  - [Package Structure Description](#package-structure-description)

## Features

- **Suffix Dynamic Mapping SQL**: Supports `field` + `suffix` to automatically map different types of queries
- **Conditional Dynamic Assembly SQL**: Supports dynamic splicing of conditions according to input parameters
- **Map Query Conditions**: Automatically convert Map parameters
- **Data Field Mapping**: Automatically convert attributes to database fields
- **Anti-SQL Injection**: Prevent SQL injection through pre-compiled SQL
- **Lambda Chained Calls**: Support chained calls to append parameter conditions
- **VO Type Conversion**: Automatically convert query results to a specified class
- **Additional Query Methods**: Add `voById`, `voByIds`, `voFirst`, `voUnique`, `voList`, `voPage` and other methods

---

## Maven Dependency

[![Maven Central](https://img.shields.io/maven-central/v/io.github.luminion/sql-booster)](https://mvnrepository.com/artifact/io.github.luminion/sql-booster)

```xml

<dependency>
    <groupId>io.github.luminion</groupId>
    <artifactId>sql-booster</artifactId>
    <version>latest</version>
</dependency>
```

Snapshot version repository address
```xml
<repositories>
  <repository>
    <name>Central Portal Snapshots</name>
    <id>central-portal-snapshots</id>
    <url>https://central.sonatype.com/repository/maven-snapshots/</url>
    <releases>
      <enabled>false</enabled>
    </releases>
    <snapshots>
      <enabled>true</enabled>
    </snapshots>
  </repository>
</repositories>
```

---

## Quick Start

[code-generator](https://github.com/luminion/code-generator) code generator has been adapted to this framework, you can generate code with one click, out of the box

### 1. Create Entity Class

If you already have an entity class, you can ignore this step

```java
// Entity class corresponding to the database
public class SysUser {
    private Long id;
    private String name;
    private Integer age;
    // getter/setter...
}
```

```java
// VO class for encapsulating query results, can inherit from the entity class, or use the entity class directly
public class SysUserVO {
    private Long id;
    private String name;
    private Integer age;
    // getter/setter...
}
```

### 2. Mapper Xml File References SQL Fragment

Get xml file content

```java
import io.github.luminion.sqlbooster.util.MapperUtils;

public static void main(String[] args) {
    String mapperContent = MapperUtils.getMapperContent(SysUser.class, SysUserVO.class);
    System.out.println(mapperContent);
}
```

Paste the obtained content into the mapper.xml file, and `join tables`/`add conditions`/`add sorting` as needed

```xml
<!--Copy the sql fragment generated by the utility class to the mapper.xml file-->
<select id="selectByWrapper" resultType="com.example.test.vo.SysUserVO">
    SELECT
    a.*
    FROM
    sys_user a
    <where>
        <include refid="sqlbooster.conditions"/>
        <!--Write custom condition SQL here, conditions that are not automatically mapped can be obtained through param1.extra, start with AND to be compatible with automatically mapped query conditions-->
        AND a.deleted = 0
        <if test="param1.extra.userDeptName != null">
            AND a.dept_id in (SELECT id FROM sys_department WHERE name = #{param1.extra.userDeptName})
        </if>
    </where>
    <trim prefix="ORDER BY" prefixOverrides=",">
        <include refid="sqlbooster.sorts"/>
        <!--Write sorting field SQL here, start with , to be compatible with automatically mapped sorting-->
        , a.created_time DESC , a.id DESC
    </trim>
</select>
```

### 3. Mapper Interface Inherits Specified Class

After inheritance, you can get `voById`, `voByIds`, `voFirst`, `voUnique`, `voList`, `voPage` and other methods

The following types of inheritance are provided, choose one of them

* Inherit `BoosterEngine`, no pagination function
* Inherit `PageHelperBooster`, full function, use `PageHelper` for pagination (you need to introduce `PageHelper` dependency yourself)
* Inherit `MybatisPlusBooster`, full function, use `IPage` for pagination (you need to introduce `Mybatis-plus` dependency yourself),

#### Mybatis Environment, Use `PageHelperBooster`

```java
import io.github.luminion.sqlbooster.extension.pagehelper.PageHelperBooster;

// Inherit PageHelperBooster
public interface SysUserMapper extends PageHelperBooster<SysUser, SysUserVO> {

}

```

> **Next step: [Usage Example](#usage-example)**

---

#### Mybatis-plus Environment, Use `MybatisPlusBooster`

For the Mybatis-plus environment, subdivided interfaces are provided for `Service`/`ServiceImpl`/`Mapper` to inherit

- `BoosterMpMapper` inherits `BaseMapper` and `MybatisPlusBooster`
- `BoosterMpServiceImpl` inherits `ServiceImpl` and `MybatisPlusBooster`
- `BoosterMpService` inherits `IService` and `MybatisPlusBooster`

```java
import io.github.luminion.sqlbooster.extension.mybatisplus.BoosterMpMapper;

// Inherit BoosterBaseMapper
// eg: BoosterBaseMapper has inherited BaseMapper, SysUserMapper does not need to inherit the original BaseMapper
public interface SysUserMapper extends BoosterMpMapper<SysUser, SysUserVO> {

}
```

```java
import io.github.luminion.sqlbooster.extension.mybatisplus.BoosterMpServiceImpl;

// Inherit BoosterMpServiceImpl
// eg: BoosterMpServiceImpl has inherited ServicImpl, SysUserServiceImpl does not need to inherit the original ServiceImpl
public class SysUserServiceImpl extends BoosterMpServiceImpl<SysUser, SysUserVO> {

}
```

```java
import io.github.luminion.sqlbooster.extension.mybatisplus.BoosterMpService;

// BoosterMpService
// eg: BoosterMpService has inherited IService, SysUserService does not need to inherit the original IService
public class SysUserService extends BoosterMpService<SysUser, SysUserVO> {

}
```

> **Next step: [Usage Example](#usage-example)**

---

#### Custom Environment, Use `BoosterEngine`, No Pagination

* `BoosterEngine` provides multiple default implementations of core functions, but does not include pagination function
* `BoosterEngine` provides implementations of methods such as `voById`, `voByIds`, `voFirst`, `voUnique`, `voList`, etc.
* The `voPage` method of `BoosterEngine` pagination query has no effect on business logic when it is not called
* The `voPage` method of `BoosterEngine` pagination query will throw an `UnsupportedOperationException` exception when called

```java
import io.github.luminion.sqlbooster.core.BoosterEngine;

// mapper inherits BoosterEngine
public interface SysUserMapper extends BoosterEngine<SysUser, SysUserVO> {

}
```

> **Next step: [Usage Example](#usage-example)**

---

#### Custom Environment, Use `BoosterEngine`, and Override Pagination Logic

* By default, this interface has 4 `voPage()` pagination methods with different parameters. You don't need to implement or override them when you don't use the pagination function.
* In actual operation, all pagination methods will eventually be overloaded to the `voPage(Wrapper, long, long)` method
* When pagination is required, only override the `voPage(Wrapper, long, long)` method and add the implementation logic of pagination

It is recommended to abstract a parent interface to write the logic, inherit `BoosterEngine`, and other Mappers will inherit this interface to avoid multiple rewrites:

```java
import io.github.luminion.sqlbooster.core.BoosterEngine;

// Custom global interface, inherits BoosterEngine
public interface CustomBooster<T> extends BoosterEngine<SysUser, SysUserVO> {

    @Override
    default Page<SysUserVO> voPage(Wrapper<SysUser> wrapper, long pageNum, long pageSize) {
        // Query preprocessing - a method provided for subclasses to override, which can be used to preprocess the wrapper. It is not necessary to call it, but it is recommended to call it to standardize behavior
        voPreProcess(wrapper);

        // !!!Important!!!, remember to call the SqlHelper.process() method
        // The SqlHelper.process() method is used to handle dynamic mapping and suffix mapping, and at the same time check the legality of conditions to prevent sql injection
        BaseHelper<T> sqlHelper = SqlHelper.of(wrapper).entity(this)
                .process(SuffixProcessor.of()::process);

        // Pagination logic, the following is a pagination example of Mybatis-plus, just replace it with your own when you actually implement it
        PageDTO<V> pageInfo = new PageDTO<>(pageNum, pageSize);
        List<V> vs = selectByBooster(sqlHelper, pageInfo); // The mapper layer method that actually executes the query
        pageInfo.setRecords(vs);
        MybatisPlusPage<V> page = new MybatisPlusPage<>(pageInfo);


        // Query post-processing - a method provided for subclasses to override, which can be used to post-process the query results. It is not necessary to call it, but it is recommended to call it to standardize behavior
        voPostProcess(page.getRecords(), sqlHelper, page);
        return null;
    }

}
```

```java
// mapper inherits custom interface
public interface SysUserMapper extends CustomBooster<SysUser, SysUserVO> {


}
```

> **Next step: [Usage Example](#usage-example)**

<br/>

---

## Usage Example

```java
import io.github.luminion.sqlbooster.model.sql.helper.SqlHelper;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/user")
public class SysUserController {

    // Introduce Mapper interface or Service interface here
    @Autowired
    private SysUserMapper sysUserMapper;

    // Query VO by ID
    @GetMapping("/{id}")
    public SysUserVO getUserById(@PathVariable Long id) {
        return sysUserMapper.voById(id);
    }

    // Query through DTO object
    @PostMapping("/dto")
    public List<SysUserVO> getUsersByDTO(@RequestBody SysUserDTO dto) {
        return sysUserMapper.voList(dto);
    }

    // Query by map condition (supports suffix mapping of different types of queries)
    @PostMapping("/map")
    public List<SysUserVO> getUsersByMap(@RequestBody Map<String, Object> params) {
        return sysUserMapper.voList(params);
    }

    // When using SqlHelper as a parameter, the front end can dynamically specify conditions and sorting through input parameters
    @PostMapping("/sql")
    public List<SysUserVO> getUsersBySql(@RequestBody SqlHelper<SysUser> sqlHelper) {
        return sysUserMapper.voList(sqlHelper);
    }

    // lambda call, add necessary conditions, such as permission roles, etc.
    @PostMapping("/lambda")
    public List<SysUserVO> getUsersBySql(@RequestBody Map<String, Object> params) {
        return SqlHelper.of(SysUser.class)
                .merge(params) // Merge or add conditions, support entity class, DTO object, map, SqlHelper, etc.
                .eq(SysUser::getState, 1) // state=1
                .ge(SysUser::getAge, 18) // age>=18
                .in(SysUser::getRoleId, Arrays.asList(1, 2))
                .like(SysUser::getUserName, "tom") // userName like '%tom%'
                .boost(sysUserMapper)
                .voList();
    }

    // Paging query
    @PostMapping("/page/{current}/{size}")
    public IPage<SysUserVO> getUserPage(@RequestBody Map<String, Object> params,
                                        @PathVariable("current") Long current,
                                        @PathVariable("size") Long size) {
        return sysUserMapper.voPage(params, current, size);
    }

    // November 2025
    // Because EasyExcel stopped updating, the sequel FastExcel was changed to Apache fesod
    // Apache fesod has not yet been incubated, and Excel related functions will be provided after the api is stable
//    // Excel export
//    @PostMapping("/excel/export/{current}/{size}")
//    public void exportExcel(@RequestBody Map<String, Object> params,
//                            @PathVariable("current") Long current,
//                            @PathVariable("size") Long size) {
//        sysUserMapper.exportExcel(fileName, SysUserVO.class);
//    }
}
```

---

## Core Features

### Dynamic Suffix Mapping SQL

- Add a special suffix to the `parameter` name to `dynamically map` to `different types` of queries
- When no suffix is added, it is equivalent to an `equal` query
- The back end can use `entity class` or `Map` to receive parameters

#### Dynamic Suffix Mapping Table

| Operator | Description | Suffix | Example (JSON Key) | Value Type |
|---|---|---|---|---|
| `=` | Equal | (none) | `"name": "mike"` | String, Number, Boolean |
| `<>` | Not equal | `Ne` / `_ne` | `"ageNe": 18` / `"age_ne": 18` | String, Number, Boolean |
| `<` | Less than | `Lt` / `_lt` | `"ageLt": 18` / `"age_lt": 18` | Number, Date |
| `<=` | Less than or equal to | `Le` / `_le` | `"ageLe": 18` / `"age_le": 18` | Number, Date |
| `>` | Greater than | `Gt` / `_gt` | `"ageGt": 18` / `"age_gt": 18` | Number, Date |
| `>=` | Greater than or equal to | `Ge` / `_ge` | `"ageGe": 18` / `"age_ge": 18` | Number, Date |
| `LIKE` | Fuzzy match | `Like` / `_like` | `"nameLike": "mike"` / `"name_like": "mike"` | String |
| `NOT LIKE` | Anti-fuzzy match | `NotLike` / `_not_like` | `"nameNotLike": "mike"` / `"name_not_like": "mike"` | String |
| `IN` | IN query | `In` / `_in` | `"stateIn": [1, 2, 3]` / `"state_in": [1, 2, 3]` | List/Array (String, Number) |
| `NOT IN` | NOT IN query | `NotIn` / `_not_in` | `"stateNotIn": [1, 2, 3]` / `"state_not_in": [1, 2, 3]` | List/Array (String, Number) |
| `IS NULL` | Is null | `IsNull` / `_is_null` | `"nameIsNull": true` / `"name_is_null": true` | Boolean (true) |
| `IS NOT NULL` | Is not null | `IsNotNull` / `_is_not_null` | `"nameIsNotNull": true` / `"name_is_not_null": true` | Boolean (true) |
| `& =` | Bitwise operation (contains) | `BitIn` / `_bit_in` | `"permissionBitIn": 4` / `"permission_bit_in": 4` | Number |
| `& = 0` | Bitwise operation (does not contain) | `BitNot` / `_bit_not` | `"permissionBitNot": 4` / `"permission_bit_not": 4` | Number |

#### Parameter Example

Query data where `name` contains `mike`, `version` is `1`, `age` is between `18-60`, and `state` is `1`, `2`, or `3`:

```json
{
  "nameLike": "mike",
  "version": 1,
  "ageGe": 18,
  "ageLt": 60,
  "stateIn": [1, 2, 3]
}
```

#### Custom Suffix Mapping

- Modify the default suffix of `SuffixProcessor` to change the default suffix mapping
- Override the verification call method of `BoosterEngine` to change the suffix mapping of the specified instance
- When creating `SqlHelper<T>`, call the `process()` processing method to handle a single mapping
- For available operators, see [Dynamic Suffix Mapping Table](#dynamic-suffix-mapping-table)

Custom example:

```java
import io.github.luminion.sqlbooster.model.sql.helper.processor.SuffixProcessor;

@SpringBootApplication
public class App {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(App.class, args);

        // Specify the mapping relationship between suffixes and operators
        HashMap<String, String> map = new HashMap<String, String>();
        map.put("_like", "LIKE");
        map.put("_ge", ">=");
        map.put("_le", "<=");
        map.put();
        map.put("_like", "LIKE");
        map.put("_not_eq", "<>");
        // Set default suffix mapping
        SuffixProcessor.defaultSuffixMap(map);
    }
}
```

### Dynamic Condition Combination SQL

- Freely specify `query conditions`/`query types`/`query values` in the input parameters
- Freely specify `sorting conditions` and `ascending/descending order` in the input parameters
- Support nested `sub-conditions` and `or` conditions
- Automatically verify parameters to prevent `SQL injection`
- Support free combination of complex conditions

#### Parameter Format
The input parameter class that supports dynamic sql is [SqlHelper](src/main/java/io/github/luminion/sqlbooster/model/sql/helper/SqlHelper.java),
its format is as follows:

```json
{
  "conditions": [
    {
      "field": "name",
      "operator": "=",
      "value": "mike"
    },
    {
      "field": "age",
      "operator": ">=",
      "value": 18
    }
  ],
  "sorts": [
    {
      "field": "id",
      "asc": true
    },
    {
      "field": "age",
      "asc": false
    }
  ]
}
```

Attribute description:

* `conditions` is used to store a group of query conditions,
    * `field` specifies the field to be queried
    * `operator` specifies the query type, the default is `=` when not passed
    * `value` specifies the query value
* `sorts` is used to store a group of sorting conditions
    * `field` specifies the field to be sorted
    * `asc` specifies whether to ascend, `true` is ascending, `false` is descending, the default is `false` when not passed

#### Query Type Mapping Table

| sql query type | description | operator parameter value | value type |
|:---|:---|:---|:---|
| `=` | Equal (default) | `=`, `==`, `eq`, `EQ` | String, Number, Boolean |
| `<>` | Not equal | `<>`, `!=`, `ne`, `NE` | String, Number, Boolean |
| `>` | Greater than | `>`, `gt`, `GT` | Number, Date |
| `>=` | Greater than or equal to | `>=`, `ge`, `GE` | Number, Date |
| `<` | Less than | `<`, `lt`, `LT` | Number, Date |
| `<=` | Less than or equal to | `<=`, `le`, `LE` | Number, Date |
| `LIKE` | Fuzzy match | `$`,`like`, `LIKE` | String |
| `NOT LIKE` | Anti-fuzzy match | `!$`,`not_like`, `NOT_LIKE` | String |
| `IN` | In the specified list | `@`,`in`, `IN` | List/Array (String, Number) |
| `NOT IN` | Not in the specified list | `!@`,`not_in`, `NOT_IN` | List/Array (String, Number) |
| `IS NULL` | Is null | `?`, `is_null`, `IS_NULL` | Boolean (true) |
| `IS NOT NULL` | Is not null | `!?`, `is_not_null`, `IS_NOT_NULL` | Boolean (true) |
| `&` | Contains the specified bit | `&`, `bit_in`, `BIT_IN` | Number |
| `!&` | Does not contain the specified bit | `!&`, `bit_not_in`, `BIT_NOT_IN` | Number |

> **Tip: Among them, `=` is the default value. When the query type is `=`, you don't need to pass the operator parameter**

#### Basic Usage

Query data where `name` is `mike`, `version` is greater than or equal to `1`, and `state` is `1`, `2`, or `3`

```json
{
  "conditions": [
    {
      "field": "name",
      "value": "mike"
    },
    {
      "field": "version",
      "operator": ">=",
      "value": 1
    },
    {
      "field": "state",
      "operator": "IN",
      "value": [1, 2, 3]
    }
  ]
}
```

#### Specify Sort Fields

Query data where `name` is `mike` and `version` is `1`, and sort the results by `id` in descending order and `age` in ascending order

```json
{
  "conditions": [
    {
      "field": "name",
      "value": "mike"
    },
    {
      "field": "version",
      "value": 1
    }
  ],
  "sorts": [
    {
      "field": "id"
    },
    {
      "field": "age",
      "asc": true
    }
  ]
}
```

#### Full Function / Complex Query

The above content simplifies the SqlHelper structure, the actual structure is:

```json
{
  "connector": "and",
  "conditions": [
    {
      "field": "name",
      "operator": "=",
      "value": "mike"
    },
    {
      "field": "age",
      "operator": ">=",
      "value": 18
    }
  ],
  "sorts": [
    {
      "field": "id"
    },
    {
      "field": "age",
      "asc": true
    }
  ],
  "child": {
    "conditions": [],
    "connector": "or",
    "child": null
  }
}
```
Field attribute description:
* `connector` is used to specify the relationship between the conditions in `conditions`
    * This attribute is an optional attribute, no need to pass, the default is `and`
    * Optional values: `and` and / `or` or
* `conditions` is used to store a group of query conditions,
    * `field` specifies the field to be queried
    * `operator` specifies the query type, the default is `=` when not passed
    * `value` specifies the query value
* `sorts` is used to store a group of sorting conditions
    * `field` specifies the field to be sorted
    * `asc` specifies whether to ascend, `true` is ascending, `false` is descending, the default is `false`
* `child` is a nestable sub-condition, `only for complex conditions`
    * This attribute can be ignored when nesting is not required
    * `sorts` parameter is not accepted under the nested level
    * If necessary, `child` can be nested under the nested level

Best practices:
- All conditions that need to be met at the same time are placed in the `conditions` of the root node
- `connector` defaults to `AND`, no need to pass when not combining `OR` conditions
- `child` does not need to be passed when not in use
- When you encounter a situation where you need to meet several necessary conditions, and there are multiple conditions that can be met at the same time, put this group of conditions into a `child` node and specify `connector` as `OR`

```json
{
  "conditions": [],
  "sorts": [],
  "child": {
    "conditions": [],
    "connector": "OR",
    "child": {
      "conditions": [],
      "connector": "OR"
    }
  }
}
```


Complex condition example: query data where the nationality is China, the mobile phone number is not empty, the name is mike or john, and the age is less than 18 or greater than 60

```sql
SELECT *
FROM sys_user
WHERE (country = 'china' AND mobile IS NOT NULL)
  AND (name = 'mike' OR name = 'john')
  AND (age < 18 OR age > 60)
```

Input parameters:

```json
{
  "conditions": [
    {
      "field": "country",
      "value": "china"
    },
    {
      "field": "mobile",
      "operator": "is_not_null",
      "value": true
    }
  ],
  "child": {
    "connector": "or",
    "conditions": [
      {
        "field": "name",
        "value": "mike"
      },
      {
        "field": "name",
        "value": "john"
      }
    ],
    "child": {
      "connector": "or",
      "conditions": [
        {
          "field": "age",
          "operator": "<",
          "value": 18
        },
        {
          "field": "age",
          "operator": ">",
          "value": 60
        }
      ]
    }
  }
}
```

## Package Structure Description

```
io.github.luminion.sqlbooster
├── core                  # Core SQL builder and engine
│   ├── Page.java
│   ├── Booster.java
│   ├── BoosterCore.java
│   ├── BoosterEngine.java
│   └── MethodReference.java
├── util                  # Various utility classes used by the project
│   ├── BoostUtils.java
│   ├── ExcelUtils.java
│   ├── MapperUtils.java
│   └── ReflectUtils.java
├── model                 # Defines data models such as API, SQL, and enums
│   ├── api
│   ├── sql
│   └── enums
├── config                # Provides automatic configuration function for Spring Boot
│   └── BoosterAutoConfiguration.java
├── provider              # Contains various provider interfaces and implementations for extension and customization
│   ├── support
│   ├── BoostProvider.java
│   ├── TableNameProvider.java
│   ├── IdPropertyProvider.java
│   ├── GetterPropertyProvider.java
│   └── PropertyToColumnAliasMapProvider.java
└── extension             # Provides integration with third-party libraries such as MyBatis, MyBatis-Plus, and PageHelper
    ├── mybatis
    ├── pagehelper
    └── mybatisplus
```
